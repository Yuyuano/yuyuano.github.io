<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>遇缘的博客</title><link>http://blog.yuzhiyuan.top</link><description>以此记录我的编程生涯</description><copyright>遇缘的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/170221043?v=4</url><title>avatar</title><link>http://blog.yuzhiyuan.top</link></image><lastBuildDate>Mon, 27 Oct 2025 10:51:57 +0000</lastBuildDate><managingEditor>遇缘的博客</managingEditor><ttl>60</ttl><webMaster>遇缘的博客</webMaster><item><title>[洛谷]级数求和</title><link>http://blog.yuzhiyuan.top/post/%5B-luo-gu-%5D-ji-shu-qiu-he.html</link><description># P1035 [NOIP 2002 普及组] 级数求和
## 题目
现已知Sn=1+1/2+1/3+1/n 
Sn&gt;k 现给出一个整数 k，要求计算出一个最小的 n，使得 Sn&gt;k
### 代码案例
```python
k = int(input()) #K的值
n = 0 #N的初始值
S = 0.0  #S的初始值
while S &lt;= k: #计算循环
    n += 1
    S += 1 / n
print(n)
```
依照题目要求，**k**为输入的值，**n**与**S**为还没计算的初始值
&gt;[!NOTE]

&lt;img width='1078' height='232' alt='Image' src='https://github.com/user-attachments/assets/92de3036-dfb3-473f-a4b1-8581c36e13d2' /&gt;

&gt;
&gt;[!TIP]
循环内容是N = 1 S+= 1/1 下一循环: 1(N) += 1 S += 1/2 (S在上一个循环已经是1/1了
&gt;。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/%5B-luo-gu-%5D-ji-shu-qiu-he.html</guid><pubDate>Mon, 27 Oct 2025 10:49:24 +0000</pubDate></item><item><title>使用Geek免费搭建一个属于自己的网站</title><link>http://blog.yuzhiyuan.top/post/shi-yong-Geek-mian-fei-da-jian-yi-ge-shu-yu-zi-ji-de-wang-zhan.html</link><description># 本网站是利用Geek模板搭建起来的
## Geek是一个开源的一个博客框架，超轻量级个人博客模板，完全基于`Github Pages` 、 `Github Issues` 和 `Github Actions`，可以称作**All in Github**。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/shi-yong-Geek-mian-fei-da-jian-yi-ge-shu-yu-zi-ji-de-wang-zhan.html</guid><pubDate>Fri, 24 Oct 2025 15:34:38 +0000</pubDate></item><item><title>抽卡模拟</title><link>http://blog.yuzhiyuan.top/post/chou-qia-mo-ni.html</link><description># 基于明日方舟的抽卡概率做的抽卡模拟
```
术语表：
| 名词  | 对应机制               |
| --- | ------------------ |
| 硬保底 | 概率固定，第 N 抽必出       |
| 软保底 | 50 抽后每抽 +2%        |
| 天井  | 300 抽可直接兑换当期 UP 六星 |
```
&gt;[!WARNING]
本篇所有代码都没有对输入做判断，请不要输入字符或者空白
&gt;

&gt;[!TIP]  
如果想让脚本更健壮，把 `guess = int(input(...))` 包成：
 ```python
 while True:
     try:
         guess = int(input('请输入 1-100 的整数：'))
         break
     except ValueError:
         print('格式错误，请重新输入！')
 ```
&gt;
## 将会分步骤一步步变难
&gt;[!NOTE]
这玩意对于初学者来说有亿点难以理解，不懂问Ai吧，或者找我
&gt;
### 标准池（6⭐概率2%） 无保底写法
```python
import random
chou = int(input('你想要抽多少发？：')) #自定义想抽多少发
def gacha():     #用def函数方便自定义抽数
    r = random.randint(1, 100)
   # random.randint(1,100) 生成的是 1~100 闭区间，共 100 个整数
    if r &lt;= 2:          # 6⭐ 2/100 = 2%
        return '⭐⭐⭐⭐⭐⭐'
    elif r &lt;= 8:
        return '⭐⭐⭐⭐⭐'
    elif r &lt;= 50:
        return '⭐⭐⭐⭐'
    else:
        return '⭐⭐⭐'
for i in range(chou): #循环输入的次数
    print(gacha()) #执行def函数并输出
```
&gt;[!NOTE]
这个用了**def函数**来自定义抽数，理解不了**def**可以把自定义抽数的代码去掉然后直接`For循环`判断抽卡的内容
&gt;
### （假）保底写法
因为明日方舟保底概率是随着抽数的增长而增长，为了方便理解，这里先介绍**硬保底**（也就是抽到多少抽必出，不随着抽数增加概率）
```python
import random

chou = int(input('你想要抽多少发？：'))

def gacha(pity):
    '''返回 (结果, 新pity)'''
    # 硬保底：第99抽必出6⭐
    if pity == 99:
        return '⭐⭐⭐⭐⭐⭐', 0

    # 正常概率
    r = random.randint(1, 100)
    if r &lt;= 2:                # 出6⭐
        return '⭐⭐⭐⭐⭐⭐', 0
    elif r &lt;= 8:
        return '⭐⭐⭐⭐⭐', pity + 1
    elif r &lt;= 50:
        return '⭐⭐⭐⭐', pity + 1
    else:
        return '⭐⭐⭐', pity + 1

pity = 0
for i in range(chou):
    result, pity = gacha(pity)
    print(result)
```
&gt;[!TIP]
要善用计数器来作为额外的计算次数道具
&gt;
### (真）保底写法
```python
import random
chou = int(input('你想要抽多少发？：'))
def gacha(pity):
    '''返回 (抽卡结果, 新的pity计数)'''
    # 计算当前 6⭐概率
    six_rate = min(2 + max(0, pity - 49) * 2, 100)   # 第51抽开始+2%  官方：50 抽之后（即第 51 抽）每抽 +2%
    r = random.randint(1, 100) 

    if r &lt;= six_rate:           # 出 6⭐
        return '⭐⭐⭐⭐⭐⭐', 0
    elif r &lt;= 8:                # 5⭐
        return '⭐⭐⭐⭐⭐', pity + 1
    elif r &lt;= 50:               # 4⭐
        return '⭐⭐⭐⭐', pity + 1
    else:                       # 3⭐
        return '⭐⭐⭐', pity + 1

pity = 0                        # 开局垫 0 抽
for i in range(chou):
    result, pity = gacha(pity)  # 抽一次，拿到新 pity
    print(result)
```

### 集大成者完整版（拥有随抽数增加保底概率增加，会歪，有统计功能）
&gt;[!CAUTION]
因为以下代码会创建**json文件**来保存数据，所以请勿在**python在线编辑器**来运行此代码
&gt;
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
明日方舟限定 UP 池模拟器（真实概率链 + 300 抽天井补发）
'''
import os
import json
import random
from collections import Counter

# ========== 用户可改参数 ==========
UP_NAME = '影焰·苇草'          # 当期 UP 六星
SAVE_FILE = 'arknights_pity.json'
# ==================================

# ---------- 工具：读档 ----------
def load_data():
    if os.path.exists(SAVE_FILE):
        with open(SAVE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {'total': 0, 'pity': 0}

# ---------- 工具：写档 ----------
def save_data(total, pity):
    with open(SAVE_FILE, 'w', encoding='utf-8') as f:
        json.dump({'total': total, 'pity': pity}, f, ensure_ascii=False)

# ---------- 核心抽卡（真实概率链） ----------
def pull_once(pity):
    '''返回 (结果字符串, 新pity, 是否六星)'''
    six_prob = min(2 + max(0, pity - 49) * 2, 100)  # 软保底
    r = random.randint(1, 100)                       # 只掷一次

    if r &lt;= six_prob:                                # 1. 六星
        up_or_ng = random.choices(['UP', '歪'], weights=[70, 30])[0]
        return (f'六星·{UP_NAME}' if up_or_ng == 'UP' else '六星·常驻'), 0, True

    elif r &lt;= six_prob + 2:                          # 2. 五星 2%
        return '五星', pity + 1, False

    elif r &lt;= six_prob + 2 + 50:                     # 3. 四星 50%
        return '四星', pity + 1, False

    else:                                            # 4. 三星 46%
        return '三星', pity + 1, False

# ---------- 主流程 ----------
def main():
    data = load_data()
    total_hist = data['total']
    pity = data['pity']

    n = int(input('本次抽多少发？：'))

    print('\n===== 抽卡开始 =====')
    record = []
    first_6 = None
    six_count = 0

    for i in range(1, n + 1):
        result, pity, is6 = pull_once(pity)  # ← 仅此处修复：pull_one → pull_once
        record.append(result)
        if is6:
            six_count += 1
            if first_6 is None:
                first_6 = i

    total_hist += n

    # ---------- 统计 ----------
    c = Counter(record)
    print('\n===== 统计 =====')
    for k, v in c.items():
        print(f'{k}: {v} 张')

    # ---------- 天井检查（自动补发） ----------
    if total_hist &gt;= 300:
        print(f'\n&gt;&gt;&gt; 累计已 {total_hist} 抽，可兑换当期 UP 六星「{UP_NAME}」！&lt;&lt;&lt;')
        if c.get(f'六星·{UP_NAME}', 0) == 0:
            c[f'六星·{UP_NAME}'] += 1
            six_count += 1
            print(f'&gt;&gt;&gt; 已自动为你兑换「六星·{UP_NAME}」，更新统计结果！&lt;&lt;&lt;')
        total_hist = 0  # 兑换后清零

    print(f'\n总计六星: {six_count} 张')
    print(f'UP 六星: {c.get(f'六星·{UP_NAME}', 0)} 张')
    print(f'歪六星: {c.get('六星·常驻', 0)} 张')
    if first_6:
        print(f'最早六星: 第 {first_6} 抽')
    print(f'当前垫抽: {pity}')
    print(f'历史累计: {total_hist} 抽')

    # ---------- 存盘 ----------
    save_data(total_hist, pity)
    print('\n数据已保存，下次继续累计。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/chou-qia-mo-ni.html</guid><pubDate>Fri, 24 Oct 2025 09:53:39 +0000</pubDate></item><item><title>猜数字</title><link>http://blog.yuzhiyuan.top/post/cai-shu-zi.html</link><description># 用 while 循环写个命令行猜数字游戏
猜数字代码依靠while循环来实现
```python
import random #加入random随机数
number = random.randint(1,100) #让number在1-100里面随机一个数
cishu = 10 #计数器，计算剩余猜测次数
number_user = int(input('猜一个1-100的数字：'))
while True:
    if number == number_user:
        print('答对了')
        break
    if cishu == 1: #如果次数用完，失败并且break
        print('次数用完了，失败了，正确答案为',number)
        break
    else:        #判断数字大小
        cishu -= 1
        if number_user &gt; number:
            print(f'大了，你还有{cishu}次机会')
            number_user = int(input())
        else:
            print(f'小了，你还有{cishu}次机会')
            number_user = int(input())
```
&gt;[!CAUTION]
循环里最后一次判断之前已经减 1，所以要把 `cishu == 1` 作为最后一次机会，否则实际会多给一次
&gt;
如果你想要 `if cishu == 0` 就刚好用完**break**的话要么把 `cishu = 10 `改为9或者将`cishu -= 1`放在**else**外面，放在**while**里面。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/cai-shu-zi.html</guid><pubDate>Fri, 24 Oct 2025 08:48:43 +0000</pubDate></item><item><title>计算1-100数字（While循环写法）</title><link>http://blog.yuzhiyuan.top/post/ji-suan-1-100-shu-zi-%EF%BC%88While-xun-huan-xie-fa-%EF%BC%89.html</link><description># 此篇为While循环写法
### 总和
```python
number = 1
total = 0 #计数器
while number &lt;= 100: #循环执行条件：直到number小于等于100时
    total += number #使每一次循环的number值加到一起
    number += 1
print(total)
```
&gt;[!CAUTION]
必须额外加一个计数器，不然使用number += number的话会使数字逐个翻倍
### 奇数和
```python
number = 1
total_odd = 0  # 奇数和计数器
while number &lt;= 99:
    total_odd += number
    number += 2  # 每次加2，只取奇数
print('奇数和：', total_odd)
```
### 偶数和
``` python
number = 2
total_even = 0  # 偶数和计数器
while number &lt;= 100:
    total_even += number
    number += 2  # 每次加2，只取偶数
print('偶数和：', total_even)
```
&gt;[!NOTE]
其实和**For循环**两者之间并没有什么太大的差别，计算步骤完全一样，只是**While循环**需要判断循环条件，而**For循环**只需要历遍给出来的值就行了
&gt;。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/ji-suan-1-100-shu-zi-%EF%BC%88While-xun-huan-xie-fa-%EF%BC%89.html</guid><pubDate>Thu, 23 Oct 2025 10:25:44 +0000</pubDate></item><item><title>计算1-100数字</title><link>http://blog.yuzhiyuan.top/post/ji-suan-1-100-shu-zi.html</link><description># 计算1-100数字的和，奇数和，偶数和
### 这是计算1-100和的Python代码，使用**For循环**写
```python
total = 0 #创建计数器
for i in range(1, 101):#For循环，历遍1-100
    total += i #进行加运算
print('1-100 总和:', total)#输出结果
```
&gt; [!CAUTION]
为什么**For循环**要写 **(1,101)** 而不是 **(1,100)** 呢，是因为For循环是不包含历遍对象末尾本身的(也就是不包含100）所以末尾要写101
&gt;
### 以下是奇数和的
```python
# 1-100 奇数和
odd_sum = 0
for i in range(1, 101, 2):   # 从 1 开始，步长 2
    odd_sum += i
print('1-100 奇数和:', odd_sum)
```
&gt;[!TIP]
**Range**历遍后面可以跟每一步走多少，这样可以用来计算奇偶数
### 偶数和
```python
# 1-100 偶数和
even_sum = 0
for i in range(2, 101, 2):   # 从 2 开始，步长 2
    even_sum += i
print('1-100 偶数和:', even_sum)
```
&gt;[!TIP]
里面的计数器变量名（如total，odd_sum,even_sum）都可以自定义，自己想填啥填啥，但最好让自己看得懂
从1开始每一步走两格可以使得每一步都是奇数，从2开始每一步走两格每一步都是偶数
&gt;。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/ji-suan-1-100-shu-zi.html</guid><pubDate>Thu, 23 Oct 2025 09:50:47 +0000</pubDate></item><item><title>水仙花</title><link>http://blog.yuzhiyuan.top/post/shui-xian-hua.html</link><description># 水仙花数计算代码
## 水仙花数是指一个三位数，其中每一位的三次方的和为它本身（abc=a**3+b**3+c**3)
### 以下使用def函数的写法

```Python
def shuixianhua(a):
    a1 = a // 100
    a2 = a // 10 % 10
    a3 = a % 10
    return (a1**3 + a2**3 + a3**3) == a  # 返回判断结果（布尔值）
number = int(input())  # 例如输入153
if shuixianhua(number):
    print(number)
else:
    print('no')
```
### 以下是直接写的
```Python
_number_=int(input())
a=_number_//100
b=_number_//10%10
c=_number_%10
if a**3+b**3+c**3==_number_:
    print('YES')
else:
    print('NO')
```
### 二者区别
第一个为迂回判断式，将计算步骤用函数表达，可以重复使用。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/shui-xian-hua.html</guid><pubDate>Wed, 22 Oct 2025 10:01:22 +0000</pubDate></item><item><title>博客测试</title><link>http://blog.yuzhiyuan.top/post/bo-ke-ce-shi.html</link><description>test。</description><guid isPermaLink="true">http://blog.yuzhiyuan.top/post/bo-ke-ce-shi.html</guid><pubDate>Tue, 21 Oct 2025 11:29:56 +0000</pubDate></item></channel></rss>